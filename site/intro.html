<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Intro stylie: DMTPOET Graph Editor</title>
  <style>
   code { 
	background-color:#ede8e4
   }
  </style>
</head>

<body>
 <h1 id="dmtpoetletsyoudesignapplicationsusingloosegraphconnections">DMTPOET lets you design applications using loose graph connections.</h1>
 <p> This program is in an extremely experimental stage and has only been tested with Chrome.  Just a word of caution, the DB is live, and there is no user auth currently. <br> <a href="http://sethtenenbaum-dmtpoet.nodejitsu.com/"> http://sethtenenbaum-dmtpoet.nodejitsu.com/ </a>  <p>
<h2 id="thetheory">THE THEORY</h1>

<p>You can build graphs using the visual editor or by using code and JSON.</p>

<p>To create a graph using JSON,  create a new Graph object, as such. <br />

<pre><code>var graph = new Graph('ptr') // ptr is the type assigned to graph, for right now, visually editable graphs must be typed to ptr
</code></pre>

<p>
once a basic graph object is created, you then use the setFromJSON method to create the structure.   The best way of doing this is to wrap objects in arrays.  </p>

<pre><code class="javascript">graph.setFromJSON({"obj":[{"obj1":"innerObj"}, {"obj2":"innerObj2"}]})
</code></pre>

<p>This will then generate an itemized graph object.  This allows a simple method to traverse the object and retrieve a pointer to the subobject. <br/>To access the graph object you then pass it an item ptr list.
It follows the pattern <code> [id, 'item', indexNumber, 'item', indexNumber,...etc...,endpoint]. </code>  At the end of the list, a suffix is sometimes appended to to get more information from the object.  This could be the index of which the graph linking occurs within, or information from the graphics renderer object.  An example suffix would be 'index', 0, or 'gfx', x.  The idea is that the objects can be accessed predictably and efficiently.</p>


<p><code>
var  innerObj = [graph.id, 'item', 0, 'item', 0, 'item', 1, 'index', 0];
// to create a reference to the object's index ...
<br/>
var innerObjLink1 = [graph.id, 'item', 0, 'item', 0, 'item', 1, 'index', 0]
</code></p>
<p> Albeit this example probably has no real usefulness, linking the two prior objects together would look like this </p>

<code>
Graph.prototype.connect(innerObj, innerObjLink1);
</code>

<p>The reason for doing this is that you can create complex behaviors based on the combination of phrase routes.  In the phrase iteration phase, each object is associated to a program class.  This class is determined by the first object in the hierarchy of the object.  In our example, this would the 'obj' program.  This obj program will then be called pointing to the sub object 'innerObj' and 'innerObj2' respectively.  After this object does what it needs to do, it then passes the information to the next object.  This chain will keep getting called until a root node is discovered or end of phrase is reached. </p>

<p>What makes this graph unique is that there are no input and outputs.  It's up to the object's program to determine the situation.  This simplifies the graph greatly, because in most cases, the last object before the root node will always store or set data, and everything else is either querying or getting data-- Storing data into a dropdown, input box, database, or anything else really.  To handle errors or manage returned data after creating or modifying data, add another object program and set that to be a root node. That will effectively end the chain, and create a new one. </p>


<h2> The User Interface </h2>
<img src="simpleEditor.gif"> </img>
<p>
The user interface is pretty simple.  Click anywhere on the left window, and a dropdown will popup.
From there, you can model your objects.  Clicking on 2 index areas will join the graphs together.  Clicking on an object will also open up a menu.  The objects can be dragged around and about.


</p>
<h2>   The Modules and Phrases</h2>
</p>

<p>
Briefly explaining this next example with the UI, serialize, Mongo and timestamp modules, a css table and a set of lists within a table can be generated. The generated UI is shared with the UI module.<br/><br>
After the UI menu gets built, the point's next() function gets bound to the button's onMouseClick event which then triggers the graph traversion. The timeStamp program receives the click and generates a time stamp, the serialization 'ptr' reflects the graph type, and the name is retrieved from the inputbox. Since the database has no more connections, the end phrase dilimeter is assumed, and it saves the data.
<p>


<img src="saveGraph2.gif"></img>

</p>
After youre done drawing up your graph, you just click the origin node, and select evaluate.  In this case, the originating node is UI.  The playground area to the right is really for testing this stuff out.  Ideally, the goal is to generate an entire content management system where the area to the right would be what the user who visits the site would see.
<p> 

The UI module is pretty simple, it just defines the different types of list rendering.  Either you can display the list of data as a table, or you can display it as a simple list.  The lists get defined as attributes in the DOM, which get managed by the CSS selectors.  If you look into the graph.css, you can see all the different attributes that get applied from the interface.   
</p>
<code>
	
	[gridtable =table] { <br>
	display:table; <br>
	padding:0px; <br>
	}<br>
	[gridtable=row] { <br>
	display:table-row; <br>
	padding:0px; <br>
	}<br>
	[gridtable=cell] { <br>
	padding:0px; <br>
	display:table-cell; <br>
	} <br>
</code>
<p>
In the next example you can see a combination of load and save graphs. 
</p>
<p>
Currently, you can reduce based on greatest time.  Other paramaters soon to come.  
</p>
<img src="loadSave.png"> </img>

<p>
<h2> The Point Object </h2>
</p>
The Point object is the base object of all the program modules. After an object gets iterated over, it then inherits all the object graph's functionality. Such functionality as <code>this.next()</code> will move the iterator to next object.  In order to deal with connecting multiple objects together within multiple parameters, there is a deferred fulfillment policy which sections off the interaction.  Once all the interactions occured in the scope of the phrase, the program then gets executed.  Right now, an array gets sent to the program which then operates on all the adjoining linkages. 
<p>
Modules must be templated to contain a <code>prototype.evaluate</code> method, as this gets called from the basic template. Event registration is another option.  That would allow triggers such as 'paramPointOver' and 'paramPointsCompleted'.
</p>
<p>
Currently, all the point modules are actually stored in the site/point.js file.  This is where the bulk of the work really went into, figuring out how to deal with some of the subtleties.  
</p>


</body>
</html>
